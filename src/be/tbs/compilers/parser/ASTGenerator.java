package be.tbs.compilers.parser;

import java.io.IOException;
import java.io.OutputStream;
import java.util.List;
import java.util.Set;

import org.antlr.runtime.CharStream;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.Token;
import org.antlr.runtime.TokenRewriteStream;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.CommonTreeAdaptor;
import org.antlr.runtime.tree.TreeAdaptor;

import be.tbs.compilers.exceptions.error.CompileError;
import be.tbs.compilers.exceptions.warning.CompileWarning;
import be.tbs.compilers.log.Log;
import be.tbs.compilers.parser.nodes.Program;

/**
 * ASTGenerator generates object model AST's using the parser generated by ANTLR.
 * @author Gino
 */
public class ASTGenerator {
	
	private smallcParser.program_return fProgram;
	private AST fAst;
	private boolean fDebug;

	/**
	 * Constructs an ASTGenerator for the given character stream.
	 * @param input Character stream containing a csmall program.
	 * @param debugOutput Whether or not debug output should be logged.
	 * @throws RecognitionException When an error is found in the input.
	 */
	public ASTGenerator (CharStream input, boolean debugOutput) throws RecognitionException {
		fDebug = debugOutput;
		
		// Create the lexer and parser.
        smallcLexer lex = new smallcLexer(input);
        TokenRewriteStream tokens = new TokenRewriteStream(lex);
        smallcParser parser = new smallcParser(tokens);
        
        TreeAdaptor myAdaptor = new CommonTreeAdaptor() {
            public Object create(Token token) {
                return new CommonTree(token);
            }
        };
        
        parser.setTreeAdaptor(myAdaptor);
        fProgram = parser.program();
        
        if (Log.getNrErrors()>0)
        	throw new RecognitionException();
	}
	
	public void toStringTree() {
		toStringTree((CommonTree) fProgram.getTree(), 0);
	}
	
	public static void toStringTree(final CommonTree tree, final int indentation) {		
		if (tree != null) {
			StringBuffer buff = new StringBuffer(indentation);
			for (int i = 0; i < indentation; i++)
				buff = buff.append("   ");
			for (int i = 0; i < tree.getChildCount(); i++) {
				System.out.println(buff.toString() + tree.getChild(i).toString());
				toStringTree((CommonTree) tree.getChild(i), indentation+1);
			}				
		}
	}
	
	public List<CompileError> getErrors() {
		return fAst.getErrors();
	}
	
	public Set<CompileWarning> getWarnings() {
	    return fAst.getWarnings();
	}
	
	/**
	 * Generate the AST Types and, upon succes, generates the machine code.
	 * @throws IOException 
	 */
	@SuppressWarnings("deprecation")
	public void generate(OutputStream o, boolean optimized) throws IOException {
		// Hide debug output if specified
		Log.setVerbose(fDebug);
		
		fAst = new AST((CommonTree) fProgram.getTree());
		fAst.setOptimized(optimized);
		Program prog = new Program(null, fAst);
		
		if (fAst.hasErrors()) {
			// Activate the log if debug output was disabled
			if (!fDebug)
				Log.setVerbose(true);
			
			// Log the errors
			for (CompileError error : fAst.getErrors()) {
				Log.error(error);
			}
		} else {		
			prog.generateCode(o);
		}

		// AST and code generation complete, no more debug output so
		// activate the log if debug output was disabled
		if (!fDebug)
			Log.setVerbose(true);
		
		// Some warnings are generated when generating code, so to keep things relatively simple, all warnings are logged last
	    if (fAst.hasWarnings()) {
			// Log the warnings
	        for (CompileWarning warning : fAst.getWarnings()) {
	            Log.warning(warning);
	            }
	        }
	    }

}
